{"child_map": {"model.gdelt.base_spotify_stock_data": ["model.gdelt.xf_spotify_aggregated"], "model.gdelt.base_spotify_in_url": ["model.gdelt.xf_spotify_date"], "model.gdelt.xf_spotify_aggregated": [], "model.gdelt.xf_spotify_date": ["model.gdelt.xf_spotify_aggregated"]}, "macros": {"macro.dbt.test_accepted_values": {"original_file_path": "macros/schema_tests/accepted_values.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro test_accepted_values(model, values) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('field')) %}\n\nwith all_values as (\n\n    select distinct\n        {{ column_name }} as value_field\n\n    from {{ model }}\n\n),\n\nvalidation_errors as (\n\n    select\n        value_field\n\n    from all_values\n    where value_field not in (\n        {% for value in values -%}\n\n            '{{ value }}' {% if not loop.last -%} , {%- endif %}\n\n        {%- endfor %}\n    )\n)\n\nselect count(*)\nfrom validation_errors\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/schema_tests/accepted_values.sql", "unique_id": "macro.dbt.test_accepted_values", "name": "test_accepted_values"}, "macro.dbt.default__get_columns_in_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__get_columns_in_relation", "name": "default__get_columns_in_relation"}, "macro.dbt.convert_datetime": {"original_file_path": "macros/etc/datetime.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}\n\n{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partiton start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}\n\n{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ dbt.exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.convert_datetime", "name": "convert_datetime"}, "macro.dbt_snowflake.snowflake__current_timestamp": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__current_timestamp", "name": "snowflake__current_timestamp"}, "macro.dbt.drop_relation_if_exists": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.drop_relation_if_exists", "name": "drop_relation_if_exists"}, "macro.dbt.reset_csv_table": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.reset_csv_table", "name": "reset_csv_table"}, "macro.dbt.create_table_as": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.create_table_as", "name": "create_table_as"}, "macro.dbt.drop_schema": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.drop_schema", "name": "drop_schema"}, "macro.dbt.create_columns": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.create_columns", "name": "create_columns"}, "macro.dbt.dates_in_range": {"original_file_path": "macros/etc/datetime.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}\n\n{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partiton start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}\n\n{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ dbt.exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.dates_in_range", "name": "dates_in_range"}, "macro.dbt_snowflake.snowflake__get_catalog": {"original_file_path": "macros/catalog.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__get_catalog(information_schemas) -%}\n\n    {%- call statement('catalog', fetch_result=True) -%}\n    {% for information_schema in information_schemas %}\n\n        (\n            with tables as (\n\n                select\n                    table_catalog as \"table_database\",\n                    table_schema as \"table_schema\",\n                    table_name as \"table_name\",\n                    table_type as \"table_type\",\n\n                    -- note: this is the _role_ that owns the table\n                    table_owner as \"table_owner\",\n\n                    'Clustering Key' as \"stats:clustering_key:label\",\n                    clustering_key as \"stats:clustering_key:value\",\n                    'The key used to cluster this table' as \"stats:clustering_key:description\",\n                    (clustering_key is not null) as \"stats:clustering_key:include\",\n\n                    'Row Count' as \"stats:row_count:label\",\n                    row_count as \"stats:row_count:value\",\n                    'An approximate count of rows in this table' as \"stats:row_count:description\",\n                    (row_count is not null) as \"stats:row_count:include\",\n\n                    'Approximate Size' as \"stats:bytes:label\",\n                    bytes as \"stats:bytes:value\",\n                    'Approximate size of the table as reported by Snowflake' as \"stats:bytes:description\",\n                    (bytes is not null) as \"stats:bytes:include\"\n\n                from {{ information_schema }}.tables\n\n            ),\n\n            columns as (\n\n                select\n                    table_catalog as \"table_database\",\n                    table_schema as \"table_schema\",\n                    table_name as \"table_name\",\n                    null as \"table_comment\",\n\n                    column_name as \"column_name\",\n                    ordinal_position as \"column_index\",\n                    data_type as \"column_type\",\n                    null as \"column_comment\"\n\n                from {{ information_schema }}.columns\n\n            )\n\n            select *\n            from tables\n            join columns using (\"table_database\", \"table_schema\", \"table_name\")\n            where \"table_schema\" != 'INFORMATION_SCHEMA'\n            order by \"column_index\"\n        )\n        {% if not loop.last %} union all {% endif %}\n\n    {% endfor %}\n  {%- endcall -%}\n\n  {{ return(load_result('catalog').table) }}\n\n{%- endmacro %}", "resource_type": "macro", "path": "macros/catalog.sql", "unique_id": "macro.dbt_snowflake.snowflake__get_catalog", "name": "snowflake__get_catalog"}, "macro.dbt.default__create_table_as": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__create_table_as", "name": "default__create_table_as"}, "macro.dbt.rename_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.rename_relation", "name": "rename_relation"}, "macro.dbt.default__get_catalog": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__get_catalog", "name": "default__get_catalog"}, "macro.dbt.in_transaction": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.in_transaction", "name": "in_transaction"}, "macro.dbt.get_catalog": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.get_catalog", "name": "get_catalog"}, "macro.dbt.archive_select": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.archive_select", "name": "archive_select"}, "macro.dbt.test_not_null": {"original_file_path": "macros/schema_tests/not_null.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro test_not_null(model) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('arg')) %}\n\nselect count(*)\nfrom {{ model }}\nwhere {{ column_name }} is null\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/schema_tests/not_null.sql", "unique_id": "macro.dbt.test_not_null", "name": "test_not_null"}, "macro.dbt.create_temporary_table": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.create_temporary_table", "name": "create_temporary_table"}, "macro.dbt.make_hook_config": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.make_hook_config", "name": "make_hook_config"}, "macro.dbt.default__rename_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__rename_relation", "name": "default__rename_relation"}, "macro.dbt_snowflake.snowflake__get_columns_in_relation": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__get_columns_in_relation", "name": "snowflake__get_columns_in_relation"}, "macro.dbt.after_commit": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.after_commit", "name": "after_commit"}, "macro.dbt.default__list_relations_without_caching": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__list_relations_without_caching", "name": "default__list_relations_without_caching"}, "macro.dbt.archive_update": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.archive_update", "name": "archive_update"}, "macro.dbt.create_view_as": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.create_view_as", "name": "create_view_as"}, "macro.dbt.generate_schema_name_for_env": {"original_file_path": "macros/etc/get_custom_schema.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Renders a schema name given a custom schema name. If the custom\n    schema name is none, then the resulting schema is just the \"schema\"\n    value in the specified target. If a schema override is specified, then\n    the resulting schema is the default schema concatenated with the \n    custom schema.\n\n    This macro can be overriden in projects to define different semantics\n    for rendering a schema name.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if custom_schema_name is none -%}\n\n        {{ default_schema }}\n\n    {%- else -%}\n\n        {{ default_schema }}_{{ custom_schema_name | trim }}\n\n    {%- endif -%}\n\n{%- endmacro %}\n\n\n{#\n    Renders a schema name given a custom schema name. In production, this macro\n    will render out the overriden schema name for a model. Otherwise, the default\n    schema specified in the active target is used.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name_for_env(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if target.name == 'prod' and custom_schema_name is not none -%}\n\n        {{ custom_schema_name | trim }}\n\n    {%- else -%}\n\n        {{ default_schema }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "resource_type": "macro", "path": "macros/etc/get_custom_schema.sql", "unique_id": "macro.dbt.generate_schema_name_for_env", "name": "generate_schema_name_for_env"}, "macro.dbt_snowflake.snowflake__list_relations_without_caching": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__list_relations_without_caching", "name": "snowflake__list_relations_without_caching"}, "macro.dbt.list_relations_without_caching": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.list_relations_without_caching", "name": "list_relations_without_caching"}, "macro.dbt_snowflake.snowflake__rename_relation": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__rename_relation", "name": "snowflake__rename_relation"}, "macro.dbt.generate_schema_name": {"original_file_path": "macros/etc/get_custom_schema.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Renders a schema name given a custom schema name. If the custom\n    schema name is none, then the resulting schema is just the \"schema\"\n    value in the specified target. If a schema override is specified, then\n    the resulting schema is the default schema concatenated with the \n    custom schema.\n\n    This macro can be overriden in projects to define different semantics\n    for rendering a schema name.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if custom_schema_name is none -%}\n\n        {{ default_schema }}\n\n    {%- else -%}\n\n        {{ default_schema }}_{{ custom_schema_name | trim }}\n\n    {%- endif -%}\n\n{%- endmacro %}\n\n\n{#\n    Renders a schema name given a custom schema name. In production, this macro\n    will render out the overriden schema name for a model. Otherwise, the default\n    schema specified in the active target is used.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name_for_env(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if target.name == 'prod' and custom_schema_name is not none -%}\n\n        {{ custom_schema_name | trim }}\n\n    {%- else -%}\n\n        {{ default_schema }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "resource_type": "macro", "path": "macros/etc/get_custom_schema.sql", "unique_id": "macro.dbt.generate_schema_name", "name": "generate_schema_name"}, "macro.dbt.default__list_schemas": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__list_schemas", "name": "default__list_schemas"}, "macro.dbt.test_relationships": {"original_file_path": "macros/schema_tests/relationships.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro test_relationships(model, to, field) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('from')) %}\n\n\nselect count(*)\nfrom (\n    select {{ column_name }} as id from {{ model }}\n) as child\nleft join (\n    select {{ field }} as id from {{ to }}\n) as parent on parent.id = child.id\nwhere child.id is not null\n  and parent.id is null\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/schema_tests/relationships.sql", "unique_id": "macro.dbt.test_relationships", "name": "test_relationships"}, "macro.dbt.default__create_csv_table": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.default__create_csv_table", "name": "default__create_csv_table"}, "macro.dbt_snowflake.materialization_table_snowflake": {"original_file_path": "macros/materializations/table.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% materialization table, adapter='snowflake' %}\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_tmp' -%}\n  {%- set backup_identifier = identifier + '__dbt_backup' -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier,\n                                                schema=schema,\n                                                database=database, type='table') -%}\n  {%- set intermediate_relation = api.Relation.create(identifier=tmp_identifier,\n                                                      schema=schema,\n                                                      database=database, type='table') -%}\n\n  /*\n      See ../view/view.sql for more information about this relation.\n  */\n\n  -- drop the backup relation if it exists, then make a new one that uses the old relation's type\n  {%- set backup_relation = adapter.get_relation(database=database, schema=schema, identifier=backup_identifier) -%}\n  {% if backup_relation is not none -%}\n    {{ adapter.drop_relation(backup_relation) }}\n  {%- endif %}\n  {%- set backup_relation = api.Relation.create(identifier=backup_identifier,\n                                                schema=schema,\n                                                database=database,\n                                                type=(old_relation.type or 'table')) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n  {%- set create_as_temporary = (exists_as_table and non_destructive_mode) -%}\n\n\n  -- drop the temp relations if they exists for some reason\n  {{ adapter.drop_relation(intermediate_relation) }}\n\n  -- setup: if the target relation already exists, truncate or drop it (if it's a view)\n  {% if non_destructive_mode -%}\n    {% if exists_as_table -%}\n      {{ adapter.truncate_relation(old_relation) }}\n    {% elif exists_as_view -%}\n      {{ adapter.drop_relation(old_relation) }}\n      {%- set old_relation = none -%}\n    {%- endif %}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% call statement('main') -%}\n    {%- if non_destructive_mode -%}\n      {%- if old_relation is not none -%}\n        {{ create_table_as(create_as_temporary, intermediate_relation, sql) }}\n\n        {% set dest_columns = adapter.get_columns_in_relation(old_relation) %}\n        {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n        insert into {{ target_relation }} ({{ dest_cols_csv }}) (\n          select {{ dest_cols_csv }}\n          from {{ intermediate_relation.include(database=(not create_as_temporary), schema=(not create_as_temporary)) }}\n        );\n      {%- else -%}\n        {{ create_table_as(create_as_temporary, target_relation, sql) }}\n      {%- endif -%}\n    {%- else -%}\n      {{ create_table_as(create_as_temporary, intermediate_relation, sql) }}\n    {%- endif -%}\n  {%- endcall %}\n\n  -- cleanup\n  {% if non_destructive_mode -%}\n    -- noop\n  {%- else -%}\n    {% if old_relation is not none %}\n      {% if old_relation.type == 'view' %}\n        {#-- This is the primary difference between Snowflake and Redshift. Renaming this view\n          -- would cause an error if the view has become invalid due to upstream schema changes #}\n        {{ log(\"Dropping relation \" ~ old_relation ~ \" because it is a view and this model is a table.\") }}\n        {{ drop_relation_if_exists(old_relation) }}\n      {% else %}\n        {{ adapter.rename_relation(target_relation, backup_relation) }}\n      {% endif %}\n    {% endif %}\n\n    {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  -- finally, drop the existing/backup relation after the commit\n  {{ drop_relation_if_exists(backup_relation) }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/table.sql", "unique_id": "macro.dbt_snowflake.materialization_table_snowflake", "name": "materialization_table_snowflake"}, "macro.dbt_snowflake.snowflake__create_view_as": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__create_view_as", "name": "snowflake__create_view_as"}, "macro.dbt.list_schemas": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.list_schemas", "name": "list_schemas"}, "macro.dbt.handle_existing_table": {"original_file_path": "macros/materializations/view/create_or_replace_view.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {{ adapter_macro(\"dbt.handle_existing_table\", full_refresh, non_destructive_mode, old_relation) }}\n{% endmacro %}\n\n{% macro default__handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {%- if not non_destructive_mode -%}\n      {{ adapter.drop_relation(old_relation) }}\n    {%- endif -%}\n{% endmacro %}\n\n{# /*\n       Core materialization implementation. BigQuery and Snowflake are similar\n       because both can use `create or replace view` where the resulting view schema\n       is not necessarily the same as the existing view. On Redshift, this would\n       result in: ERROR:  cannot change number of columns in view\n\n       This implementation is superior to the create_temp, swap_with_existing, drop_old\n       paradigm because transactions don't run DDL queries atomically on Snowflake. By using\n       `create or replace view`, the materialization becomes atomic in nature.\n    */\n#}\n\n{% macro create_or_replace_view(run_outside_transaction_hooks=True) %}\n  {%- set identifier = model['alias'] -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n\n  {% if run_outside_transaction_hooks %}\n      -- no transactions on BigQuery\n      {{ run_hooks(pre_hooks, inside_transaction=False) }}\n  {% endif %}\n\n  -- `BEGIN` happens here on Snowflake\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(flags.FULL_REFRESH, non_destructive_mode, old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% if non_destructive_mode -%}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(target_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if run_outside_transaction_hooks %}\n      -- No transactions on BigQuery\n      {{ run_hooks(post_hooks, inside_transaction=False) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/view/create_or_replace_view.sql", "unique_id": "macro.dbt.handle_existing_table", "name": "handle_existing_table"}, "macro.dbt.create_csv_table": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.create_csv_table", "name": "create_csv_table"}, "macro.dbt.materialization_view_default": {"original_file_path": "macros/materializations/view/view.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{%- materialization view, default -%}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_tmp' -%}\n  {%- set backup_identifier = identifier + '__dbt_backup' -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, database=database,\n                                                type='view') -%}\n  {%- set intermediate_relation = api.Relation.create(identifier=tmp_identifier,\n                                                      schema=schema, database=database, type='view') -%}\n\n  /*\n     This relation (probably) doesn't exist yet. If it does exist, it's a leftover from\n     a previous run, and we're going to try to drop it immediately. At the end of this\n     materialization, we're going to rename the \"old_relation\" to this identifier,\n     and then we're going to drop it. In order to make sure we run the correct one of:\n       - drop view ...\n       - drop table ...\n\n     We need to set the type of this relation to be the type of the old_relation, if it exists,\n     or else \"view\" as a sane default if it does not. Note that if the old_relation does not\n     exist, then there is nothing to move out of the way and subsequentally drop. In that case,\n     this relation will be effectively unused.\n  */\n  {%- set backup_relation = api.Relation.create(identifier=backup_identifier,\n                                                schema=schema, database=database,\n                                                type=(old_relation.type or 'view')) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- drop the temp relations if they exists for some reason\n  {{ adapter.drop_relation(intermediate_relation) }}\n  {{ adapter.drop_relation(backup_relation) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% if should_ignore -%}\n    {#\n      -- Materializations need to a statement with name='main'.\n      -- We could issue a no-op query here (like `select 1`), but that's wasteful. Instead:\n      --   1) write the sql contents out to the compiled dirs\n      --   2) return a status and result to the caller\n    #}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(intermediate_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  -- cleanup\n  {% if not should_ignore -%}\n    -- move the existing view out of the way\n    {% if old_relation is not none %}\n      {{ adapter.rename_relation(target_relation, backup_relation) }}\n    {% endif %}\n    {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if not should_ignore %}\n    {{ drop_relation_if_exists(backup_relation) }}\n  {% endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{%- endmaterialization -%}", "resource_type": "macro", "path": "macros/materializations/view/view.sql", "unique_id": "macro.dbt.materialization_view_default", "name": "materialization_view_default"}, "macro.dbt.default__create_columns": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.default__create_columns", "name": "default__create_columns"}, "macro.dbt.load_csv_rows": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.load_csv_rows", "name": "load_csv_rows"}, "macro.dbt.create_or_replace_view": {"original_file_path": "macros/materializations/view/create_or_replace_view.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {{ adapter_macro(\"dbt.handle_existing_table\", full_refresh, non_destructive_mode, old_relation) }}\n{% endmacro %}\n\n{% macro default__handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {%- if not non_destructive_mode -%}\n      {{ adapter.drop_relation(old_relation) }}\n    {%- endif -%}\n{% endmacro %}\n\n{# /*\n       Core materialization implementation. BigQuery and Snowflake are similar\n       because both can use `create or replace view` where the resulting view schema\n       is not necessarily the same as the existing view. On Redshift, this would\n       result in: ERROR:  cannot change number of columns in view\n\n       This implementation is superior to the create_temp, swap_with_existing, drop_old\n       paradigm because transactions don't run DDL queries atomically on Snowflake. By using\n       `create or replace view`, the materialization becomes atomic in nature.\n    */\n#}\n\n{% macro create_or_replace_view(run_outside_transaction_hooks=True) %}\n  {%- set identifier = model['alias'] -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n\n  {% if run_outside_transaction_hooks %}\n      -- no transactions on BigQuery\n      {{ run_hooks(pre_hooks, inside_transaction=False) }}\n  {% endif %}\n\n  -- `BEGIN` happens here on Snowflake\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(flags.FULL_REFRESH, non_destructive_mode, old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% if non_destructive_mode -%}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(target_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if run_outside_transaction_hooks %}\n      -- No transactions on BigQuery\n      {{ run_hooks(post_hooks, inside_transaction=False) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/view/create_or_replace_view.sql", "unique_id": "macro.dbt.create_or_replace_view", "name": "create_or_replace_view"}, "macro.dbt.default__archive_scd_hash": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.default__archive_scd_hash", "name": "default__archive_scd_hash"}, "macro.dbt.default__create_schema": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__create_schema", "name": "default__create_schema"}, "macro.dbt.adapter_macro": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.adapter_macro", "name": "adapter_macro"}, "macro.dbt.column_list": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.column_list", "name": "column_list"}, "macro.dbt.basic_load_csv_rows": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.basic_load_csv_rows", "name": "basic_load_csv_rows"}, "macro.dbt.materialization_table_default": {"original_file_path": "macros/materializations/table/table.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% materialization table, default %}\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_tmp' -%}\n  {%- set backup_identifier = identifier + '__dbt_backup' -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier,\n                                                schema=schema,\n                                                database=database,\n                                                type='table') -%}\n  {%- set intermediate_relation = api.Relation.create(identifier=tmp_identifier,\n                                                      schema=schema,\n                                                      database=database,\n                                                      type='table') -%}\n\n  /*\n      See ../view/view.sql for more information about this relation.\n  */\n  {%- set backup_relation = api.Relation.create(identifier=backup_identifier,\n                                                schema=schema,\n                                                database=database,\n                                                type=(old_relation.type or 'table')) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n  {%- set create_as_temporary = (exists_as_table and non_destructive_mode) -%}\n\n\n  -- drop the temp relations if they exists for some reason\n  {{ adapter.drop_relation(intermediate_relation) }}\n  {{ adapter.drop_relation(backup_relation) }}\n\n  -- setup: if the target relation already exists, truncate or drop it (if it's a view)\n  {% if non_destructive_mode -%}\n    {% if exists_as_table -%}\n      {{ adapter.truncate_relation(old_relation) }}\n    {% elif exists_as_view -%}\n      {{ adapter.drop_relation(old_relation) }}\n      {%- set old_relation = none -%}\n    {%- endif %}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% call statement('main') -%}\n    {%- if non_destructive_mode -%}\n      {%- if old_relation is not none -%}\n        {{ create_table_as(create_as_temporary, intermediate_relation, sql) }}\n\n        {% set dest_columns = adapter.get_columns_in_relation(target_relation) %}\n        {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n        insert into {{ target_relation }} ({{ dest_cols_csv }}) (\n          select {{ dest_cols_csv }}\n          from {{ intermediate_relation.include(database=(not create_as_temporary),\n                                                schema=(not create_as_temporary)) }}\n        );\n      {%- else -%}\n        {{ create_table_as(create_as_temporary, target_relation, sql) }}\n      {%- endif -%}\n    {%- else -%}\n      {{ create_table_as(create_as_temporary, intermediate_relation, sql) }}\n    {%- endif -%}\n  {%- endcall %}\n\n  -- cleanup\n  {% if non_destructive_mode -%}\n    -- noop\n  {%- else -%}\n    {% if old_relation is not none %}\n        {{ adapter.rename_relation(target_relation, backup_relation) }}\n    {% endif %}\n\n    {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  -- finally, drop the existing/backup relation after the commit\n  {{ drop_relation_if_exists(backup_relation) }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/table/table.sql", "unique_id": "macro.dbt.materialization_table_default", "name": "materialization_table_default"}, "macro.dbt.default__information_schema_name": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__information_schema_name", "name": "default__information_schema_name"}, "macro.dbt_snowflake.snowflake__create_table_as": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__create_table_as", "name": "snowflake__create_table_as"}, "macro.dbt.before_begin": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.before_begin", "name": "before_begin"}, "macro.dbt.create_archive_table": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.create_archive_table", "name": "create_archive_table"}, "macro.dbt.materialization_seed_default": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.materialization_seed_default", "name": "materialization_seed_default"}, "macro.dbt.default__load_csv_rows": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.default__load_csv_rows", "name": "default__load_csv_rows"}, "macro.dbt.default__alter_column_type": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__alter_column_type", "name": "default__alter_column_type"}, "macro.dbt.column_list_for_create_table": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.column_list_for_create_table", "name": "column_list_for_create_table"}, "macro.dbt.get_columns_in_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.get_columns_in_relation", "name": "get_columns_in_relation"}, "macro.dbt.collect_freshness": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.collect_freshness", "name": "collect_freshness"}, "macro.dbt.default__create_temporary_table": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.default__create_temporary_table", "name": "default__create_temporary_table"}, "macro.dbt.alter_column_type": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.alter_column_type", "name": "alter_column_type"}, "macro.dbt.drop_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.drop_relation", "name": "drop_relation"}, "macro.dbt.information_schema_name": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.information_schema_name", "name": "information_schema_name"}, "macro.dbt.materialization_archive_default": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.materialization_archive_default", "name": "materialization_archive_default"}, "macro.dbt.default__create_view_as": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__create_view_as", "name": "default__create_view_as"}, "macro.dbt.current_timestamp": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.current_timestamp", "name": "current_timestamp"}, "macro.dbt.default__truncate_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__truncate_relation", "name": "default__truncate_relation"}, "macro.dbt.dbt__incremental_delete": {"original_file_path": "macros/materializations/incremental/incremental.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro dbt__incremental_delete(target_relation, tmp_relation) -%}\n\n  {%- set unique_key = config.require('unique_key') -%}\n\n  delete\n  from {{ target_relation }}\n  where ({{ unique_key }}) in (\n    select ({{ unique_key }})\n    from {{ tmp_relation.include(schema=False, database=False) }}\n  );\n\n{%- endmacro %}\n\n{% materialization incremental, default -%}\n  {%- set sql_where = config.get('sql_where') -%}\n  {%- set unique_key = config.get('unique_key') -%}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_incremental_tmp' -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, database=database,  type='table') -%}\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier,\n                                             schema=schema,\n                                             database=database, type='table') -%}\n\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_not_as_table = (old_relation is not none and not old_relation.is_table) -%}\n\n  {%- set should_truncate = (non_destructive_mode and full_refresh_mode and exists_as_table) -%}\n  {%- set should_drop = (not should_truncate and (full_refresh_mode or exists_not_as_table)) -%}\n  {%- set force_create = (flags.FULL_REFRESH and not flags.NON_DESTRUCTIVE) -%}\n\n  -- setup\n  {% if old_relation is none -%}\n    -- noop\n  {%- elif should_truncate -%}\n    {{ adapter.truncate_relation(old_relation) }}\n  {%- elif should_drop -%}\n    {{ adapter.drop_relation(old_relation) }}\n    {%- set old_relation = none -%}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% if force_create or old_relation is none -%}\n    {%- call statement('main') -%}\n      {{ create_table_as(False, target_relation, sql) }}\n    {%- endcall -%}\n  {%- else -%}\n     {%- call statement() -%}\n\n       {% set tmp_table_sql -%}\n         {# We are using a subselect instead of a CTE here to allow PostgreSQL to use indexes. -#}\n         select * from (\n           {{ sql }}\n         ) as dbt_incr_sbq\n\n         {% if sql_where %}\n         where ({{ sql_where }})\n           or ({{ sql_where }}) is null\n         {% endif %}\n       {%- endset %}\n\n       {{ dbt.create_table_as(True, tmp_relation, tmp_table_sql) }}\n\n     {%- endcall -%}\n\n     {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                           to_relation=target_relation) }}\n\n     {%- call statement('main') -%}\n       {% set dest_columns = adapter.get_columns_in_relation(target_relation) %}\n       {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n       {% if unique_key is not none -%}\n\n         {{ dbt__incremental_delete(target_relation, tmp_relation) }}\n\n       {%- endif %}\n\n       insert into {{ target_relation }} ({{ dest_cols_csv }})\n       (\n         select {{ dest_cols_csv }}\n         from {{ tmp_relation.include(schema=False, database=False) }}\n       );\n     {% endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{%- endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/incremental/incremental.sql", "unique_id": "macro.dbt.dbt__incremental_delete", "name": "dbt__incremental_delete"}, "macro.dbt.materialization_incremental_default": {"original_file_path": "macros/materializations/incremental/incremental.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro dbt__incremental_delete(target_relation, tmp_relation) -%}\n\n  {%- set unique_key = config.require('unique_key') -%}\n\n  delete\n  from {{ target_relation }}\n  where ({{ unique_key }}) in (\n    select ({{ unique_key }})\n    from {{ tmp_relation.include(schema=False, database=False) }}\n  );\n\n{%- endmacro %}\n\n{% materialization incremental, default -%}\n  {%- set sql_where = config.get('sql_where') -%}\n  {%- set unique_key = config.get('unique_key') -%}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_incremental_tmp' -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, database=database,  type='table') -%}\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier,\n                                             schema=schema,\n                                             database=database, type='table') -%}\n\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_not_as_table = (old_relation is not none and not old_relation.is_table) -%}\n\n  {%- set should_truncate = (non_destructive_mode and full_refresh_mode and exists_as_table) -%}\n  {%- set should_drop = (not should_truncate and (full_refresh_mode or exists_not_as_table)) -%}\n  {%- set force_create = (flags.FULL_REFRESH and not flags.NON_DESTRUCTIVE) -%}\n\n  -- setup\n  {% if old_relation is none -%}\n    -- noop\n  {%- elif should_truncate -%}\n    {{ adapter.truncate_relation(old_relation) }}\n  {%- elif should_drop -%}\n    {{ adapter.drop_relation(old_relation) }}\n    {%- set old_relation = none -%}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% if force_create or old_relation is none -%}\n    {%- call statement('main') -%}\n      {{ create_table_as(False, target_relation, sql) }}\n    {%- endcall -%}\n  {%- else -%}\n     {%- call statement() -%}\n\n       {% set tmp_table_sql -%}\n         {# We are using a subselect instead of a CTE here to allow PostgreSQL to use indexes. -#}\n         select * from (\n           {{ sql }}\n         ) as dbt_incr_sbq\n\n         {% if sql_where %}\n         where ({{ sql_where }})\n           or ({{ sql_where }}) is null\n         {% endif %}\n       {%- endset %}\n\n       {{ dbt.create_table_as(True, tmp_relation, tmp_table_sql) }}\n\n     {%- endcall -%}\n\n     {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                           to_relation=target_relation) }}\n\n     {%- call statement('main') -%}\n       {% set dest_columns = adapter.get_columns_in_relation(target_relation) %}\n       {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n       {% if unique_key is not none -%}\n\n         {{ dbt__incremental_delete(target_relation, tmp_relation) }}\n\n       {%- endif %}\n\n       insert into {{ target_relation }} ({{ dest_cols_csv }})\n       (\n         select {{ dest_cols_csv }}\n         from {{ tmp_relation.include(schema=False, database=False) }}\n       );\n     {% endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{%- endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/incremental/incremental.sql", "unique_id": "macro.dbt.materialization_incremental_default", "name": "materialization_incremental_default"}, "macro.dbt.default__drop_schema": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__drop_schema", "name": "default__drop_schema"}, "macro.dbt.get_merge_sql": {"original_file_path": "macros/materializations/common/merge.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns) -%}\n  {{ adapter_macro('get_merge_sql', target, source, unique_key, dest_columns) }}\n{%- endmacro %}\n\n\n{% macro common_get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {%- set dest_cols_csv = dest_columns | map(attribute=\"name\") | join(', ') -%}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n\n    {% if unique_key %}\n        on DBT_INTERNAL_SOURCE.{{ unique_key }} = DBT_INTERNAL_DEST.{{ unique_key }}\n    {% else %}\n        on FALSE\n    {% endif %}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column in dest_columns -%}\n            {{ column.name }} = DBT_INTERNAL_SOURCE.{{ column.name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}\n\n{% macro default__get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {% set typename = adapter.type() %}\n\n    {{ exceptions.raise_compiler_error(\n        'get_merge_sql is not implemented for {}'.format(typename)\n       )\n    }}\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/common/merge.sql", "unique_id": "macro.dbt.get_merge_sql", "name": "get_merge_sql"}, "macro.dbt.default__collect_freshness": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__collect_freshness", "name": "default__collect_freshness"}, "macro.dbt.default__check_schema_exists": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__check_schema_exists", "name": "default__check_schema_exists"}, "macro.dbt_snowflake.materialization_view_snowflake": {"original_file_path": "macros/materializations/view.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% materialization view, adapter='snowflake' -%}\n    {{ create_or_replace_view() }}\n{%- endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/view.sql", "unique_id": "macro.dbt_snowflake.materialization_view_snowflake", "name": "materialization_view_snowflake"}, "macro.dbt_snowflake.snowflake__get_merge_sql": {"original_file_path": "macros/materializations/merge.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__get_merge_sql(target, source, unique_key, dest_columns) %}\n    {{ common_get_merge_sql(target, source, unique_key, dest_columns) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/merge.sql", "unique_id": "macro.dbt_snowflake.snowflake__get_merge_sql", "name": "snowflake__get_merge_sql"}, "macro.dbt.statement": {"original_file_path": "macros/core.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro statement(name=None, fetch_result=False, auto_begin=True) -%}\n  {%- if execute: -%}\n    {%- set sql = render(caller()) -%}\n\n    {%- if name == 'main' -%}\n      {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n      {{ write(sql) }}\n    {%- endif -%}\n\n    {%- set status, res = adapter.execute(sql, auto_begin=auto_begin, fetch=fetch_result) -%}\n    {%- if name is not none -%}\n      {{ store_result(name, status=status, agate_table=res) }}\n    {%- endif -%}\n\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro noop_statement(name=None, status=None, res=None) -%}\n  {%- set sql = render(caller()) -%}\n\n  {%- if name == 'main' -%}\n    {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n    {{ write(sql) }}\n  {%- endif -%}\n\n  {%- if name is not none -%}\n    {{ store_result(name, status=status, agate_table=res) }}\n  {%- endif -%}\n\n{%- endmacro %}", "resource_type": "macro", "path": "macros/core.sql", "unique_id": "macro.dbt.statement", "name": "statement"}, "macro.dbt.default__handle_existing_table": {"original_file_path": "macros/materializations/view/create_or_replace_view.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {{ adapter_macro(\"dbt.handle_existing_table\", full_refresh, non_destructive_mode, old_relation) }}\n{% endmacro %}\n\n{% macro default__handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {%- if not non_destructive_mode -%}\n      {{ adapter.drop_relation(old_relation) }}\n    {%- endif -%}\n{% endmacro %}\n\n{# /*\n       Core materialization implementation. BigQuery and Snowflake are similar\n       because both can use `create or replace view` where the resulting view schema\n       is not necessarily the same as the existing view. On Redshift, this would\n       result in: ERROR:  cannot change number of columns in view\n\n       This implementation is superior to the create_temp, swap_with_existing, drop_old\n       paradigm because transactions don't run DDL queries atomically on Snowflake. By using\n       `create or replace view`, the materialization becomes atomic in nature.\n    */\n#}\n\n{% macro create_or_replace_view(run_outside_transaction_hooks=True) %}\n  {%- set identifier = model['alias'] -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n\n  {% if run_outside_transaction_hooks %}\n      -- no transactions on BigQuery\n      {{ run_hooks(pre_hooks, inside_transaction=False) }}\n  {% endif %}\n\n  -- `BEGIN` happens here on Snowflake\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(flags.FULL_REFRESH, non_destructive_mode, old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% if non_destructive_mode -%}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(target_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if run_outside_transaction_hooks %}\n      -- No transactions on BigQuery\n      {{ run_hooks(post_hooks, inside_transaction=False) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/view/create_or_replace_view.sql", "unique_id": "macro.dbt.default__handle_existing_table", "name": "default__handle_existing_table"}, "macro.dbt.run_hooks": {"original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/helpers.sql", "unique_id": "macro.dbt.run_hooks", "name": "run_hooks"}, "macro.dbt.common_get_merge_sql": {"original_file_path": "macros/materializations/common/merge.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns) -%}\n  {{ adapter_macro('get_merge_sql', target, source, unique_key, dest_columns) }}\n{%- endmacro %}\n\n\n{% macro common_get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {%- set dest_cols_csv = dest_columns | map(attribute=\"name\") | join(', ') -%}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n\n    {% if unique_key %}\n        on DBT_INTERNAL_SOURCE.{{ unique_key }} = DBT_INTERNAL_DEST.{{ unique_key }}\n    {% else %}\n        on FALSE\n    {% endif %}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column in dest_columns -%}\n            {{ column.name }} = DBT_INTERNAL_SOURCE.{{ column.name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}\n\n{% macro default__get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {% set typename = adapter.type() %}\n\n    {{ exceptions.raise_compiler_error(\n        'get_merge_sql is not implemented for {}'.format(typename)\n       )\n    }}\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/common/merge.sql", "unique_id": "macro.dbt.common_get_merge_sql", "name": "common_get_merge_sql"}, "macro.dbt.default__archive_update": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.default__archive_update", "name": "default__archive_update"}, "macro.dbt.partition_range": {"original_file_path": "macros/etc/datetime.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}\n\n{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partiton start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}\n\n{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ dbt.exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.partition_range", "name": "partition_range"}, "macro.dbt.truncate_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.truncate_relation", "name": "truncate_relation"}, "macro.dbt.default__reset_csv_table": {"original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/seed/seed.sql", "unique_id": "macro.dbt.default__reset_csv_table", "name": "default__reset_csv_table"}, "macro.dbt.noop_statement": {"original_file_path": "macros/core.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro statement(name=None, fetch_result=False, auto_begin=True) -%}\n  {%- if execute: -%}\n    {%- set sql = render(caller()) -%}\n\n    {%- if name == 'main' -%}\n      {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n      {{ write(sql) }}\n    {%- endif -%}\n\n    {%- set status, res = adapter.execute(sql, auto_begin=auto_begin, fetch=fetch_result) -%}\n    {%- if name is not none -%}\n      {{ store_result(name, status=status, agate_table=res) }}\n    {%- endif -%}\n\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro noop_statement(name=None, status=None, res=None) -%}\n  {%- set sql = render(caller()) -%}\n\n  {%- if name == 'main' -%}\n    {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n    {{ write(sql) }}\n  {%- endif -%}\n\n  {%- if name is not none -%}\n    {{ store_result(name, status=status, agate_table=res) }}\n  {%- endif -%}\n\n{%- endmacro %}", "resource_type": "macro", "path": "macros/core.sql", "unique_id": "macro.dbt.noop_statement", "name": "noop_statement"}, "macro.dbt.create_schema": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.create_schema", "name": "create_schema"}, "macro.dbt.test_unique": {"original_file_path": "macros/schema_tests/unique.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro test_unique(model) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('arg')) %}\n\nselect count(*)\nfrom (\n\n    select\n        {{ column_name }}\n\n    from {{ model }}\n    where {{ column_name }} is not null\n    group by {{ column_name }}\n    having count(*) > 1\n\n) validation_errors\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/schema_tests/unique.sql", "unique_id": "macro.dbt.test_unique", "name": "test_unique"}, "macro.dbt.archive_scd_hash": {"original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "resource_type": "macro", "path": "macros/materializations/archive/archive.sql", "unique_id": "macro.dbt.archive_scd_hash", "name": "archive_scd_hash"}, "macro.dbt.default__get_merge_sql": {"original_file_path": "macros/materializations/common/merge.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns) -%}\n  {{ adapter_macro('get_merge_sql', target, source, unique_key, dest_columns) }}\n{%- endmacro %}\n\n\n{% macro common_get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {%- set dest_cols_csv = dest_columns | map(attribute=\"name\") | join(', ') -%}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n\n    {% if unique_key %}\n        on DBT_INTERNAL_SOURCE.{{ unique_key }} = DBT_INTERNAL_DEST.{{ unique_key }}\n    {% else %}\n        on FALSE\n    {% endif %}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column in dest_columns -%}\n            {{ column.name }} = DBT_INTERNAL_SOURCE.{{ column.name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}\n\n{% macro default__get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {% set typename = adapter.type() %}\n\n    {{ exceptions.raise_compiler_error(\n        'get_merge_sql is not implemented for {}'.format(typename)\n       )\n    }}\n\n{% endmacro %}", "resource_type": "macro", "path": "macros/materializations/common/merge.sql", "unique_id": "macro.dbt.default__get_merge_sql", "name": "default__get_merge_sql"}, "macro.dbt.sql_convert_columns_in_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.sql_convert_columns_in_relation", "name": "sql_convert_columns_in_relation"}, "macro.dbt.is_incremental": {"original_file_path": "macros/etc/is_incremental.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro is_incremental() %}\n    {#-- do not run introspective queries in parsing #}\n    {% if not execute %}\n        {{ return(False) }}\n    {% else %}\n        {% set relation = adapter.get_relation(this.database, this.schema, this.table) %}\n        {{ return(relation is not none and relation.type == 'table' and not flags.FULL_REFRESH) }}\n    {% endif %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/etc/is_incremental.sql", "unique_id": "macro.dbt.is_incremental", "name": "is_incremental"}, "macro.dbt_snowflake.snowflake__check_schema_exists": {"original_file_path": "macros/adapters.sql", "package_name": "dbt_snowflake", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/snowflake", "raw_sql": "{% macro snowflake__create_table_as(temporary, relation, sql) -%}\n  {% if temporary %}\n    use schema {{ adapter.quote_as_configured(schema, 'schema') }};\n  {% endif %}\n\n  {%- set transient = config.get('transient', default=true) -%}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif transient -%}\n    transient\n  {%- endif %} table {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__create_view_as(relation, sql) -%}\n  create or replace view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n{% macro snowflake__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from\n      {{ relation.information_schema('columns') }}\n\n      where table_name ilike '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema ilike '{{ relation.schema }}'\n        {% endif %}\n        {% if relation.database %}\n        and table_catalog ilike '{{ relation.database }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n\n{% endmacro %}\n\n\n{% macro snowflake__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      table_catalog as database,\n      table_name as name,\n      table_schema as schema,\n      case when table_type = 'BASE TABLE' then 'table'\n           when table_type = 'VIEW' then 'view'\n           else table_type\n      end as table_type\n    from {{ information_schema }}.tables\n    where table_schema ilike '{{ schema }}'\n      and table_catalog ilike '{{ information_schema.database.lower() }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n\n{% macro snowflake__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where upper(schema_name) = upper('{{ schema }}')\n            and upper(catalog_name) = upper('{{ information_schema.database }}')\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{%- endmacro %}\n\n{% macro snowflake__current_timestamp() -%}\n  convert_timezone('UTC', current_timestamp())\n{%- endmacro %}\n\n\n{% macro snowflake__rename_relation(from_relation, to_relation) -%}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ to_relation }}\n  {%- endcall %}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters.sql", "unique_id": "macro.dbt_snowflake.snowflake__check_schema_exists", "name": "snowflake__check_schema_exists"}, "macro.dbt.check_schema_exists": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.check_schema_exists", "name": "check_schema_exists"}, "macro.dbt.default__create_archive_table": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__create_archive_table", "name": "default__create_archive_table"}, "macro.dbt.default__drop_relation": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__drop_relation", "name": "default__drop_relation"}, "macro.dbt.default__current_timestamp": {"original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "tags": [], "depends_on": {"macros": []}, "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name='{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "resource_type": "macro", "path": "macros/adapters/common.sql", "unique_id": "macro.dbt.default__current_timestamp", "name": "default__current_timestamp"}}, "generated_at": "2019-05-21T15:07:23.222461Z", "parent_map": {"model.gdelt.base_spotify_stock_data": [], "model.gdelt.base_spotify_in_url": [], "model.gdelt.xf_spotify_aggregated": ["model.gdelt.base_spotify_stock_data", "model.gdelt.xf_spotify_date"], "model.gdelt.xf_spotify_date": ["model.gdelt.base_spotify_in_url"]}, "docs": {"dbt.__overview__": {"package_name": "dbt", "original_file_path": "docs/overview.md", "root_path": "/usr/local/lib/python2.7/dist-packages/dbt/include/global_project", "unique_id": "dbt.__overview__", "file_contents": "\n{% docs __overview__ %}\n\n### Welcome!\n\nWelcome to the auto-generated documentation for your dbt project!\n\n### Navigation\n\nYou can use the `Project` and `Database` navigation tabs on the left side of the window to explore the models\nin your project.\n\n#### Project Tab\nThe `Project` tab mirrors the directory structure of your dbt project. In this tab, you can see all of the\nmodels defined in your dbt project, as well as models imported from dbt packages.\n\n#### Database Tab\nThe `Database` tab also exposes your models, but in a format that looks more like a database explorer. This view\nshows relations (tables and views) grouped into database schemas. Note that ephemeral models are _not_ shown\nin this interface, as they do not exist in the database.\n\n### Graph Exploration\nYou can click the blue icon on the bottom-right corner of the page to view the lineage graph of your models.\n\nOn model pages, you'll see the immediate parents and children of the model you're exploring. By clicking the `Expand`\nbutton at the top-right of this lineage pane, you'll be able to see all of the models that are used to build,\nor are built from, the model you're exploring.\n\nOnce expanded, you'll be able to use the `--models` and `--exclude` model selection syntax to filter the\nmodels in the graph. For more information on model selection, check out the [dbt docs](https://docs.getdbt.com/reference#section-specifying-models-to-run).\n\nNote that you can also right-click on models to interactively filter and explore the graph.\n\n---\n\n### More information\n\n- [What is dbt](https://docs.getdbt.com/docs/overview)?\n- Read the [dbt viewpoint](https://docs.getdbt.com/docs/viewpoint)\n- [Installation](https://docs.getdbt.com/docs/installation)\n- Join the [chat](https://slack.getdbt.com/) on Slack for live questions and support.\n\n{% enddocs %}\n", "block_contents": "### Welcome!\n\nWelcome to the auto-generated documentation for your dbt project!\n\n### Navigation\n\nYou can use the `Project` and `Database` navigation tabs on the left side of the window to explore the models\nin your project.\n\n#### Project Tab\nThe `Project` tab mirrors the directory structure of your dbt project. In this tab, you can see all of the\nmodels defined in your dbt project, as well as models imported from dbt packages.\n\n#### Database Tab\nThe `Database` tab also exposes your models, but in a format that looks more like a database explorer. This view\nshows relations (tables and views) grouped into database schemas. Note that ephemeral models are _not_ shown\nin this interface, as they do not exist in the database.\n\n### Graph Exploration\nYou can click the blue icon on the bottom-right corner of the page to view the lineage graph of your models.\n\nOn model pages, you'll see the immediate parents and children of the model you're exploring. By clicking the `Expand`\nbutton at the top-right of this lineage pane, you'll be able to see all of the models that are used to build,\nor are built from, the model you're exploring.\n\nOnce expanded, you'll be able to use the `--models` and `--exclude` model selection syntax to filter the\nmodels in the graph. For more information on model selection, check out the [dbt docs](https://docs.getdbt.com/reference#section-specifying-models-to-run).\n\nNote that you can also right-click on models to interactively filter and explore the graph.\n\n---\n\n### More information\n\n- [What is dbt](https://docs.getdbt.com/docs/overview)?\n- Read the [dbt viewpoint](https://docs.getdbt.com/docs/viewpoint)\n- [Installation](https://docs.getdbt.com/docs/installation)\n- Join the [chat](https://slack.getdbt.com/) on Slack for live questions and support.", "path": "overview.md", "resource_type": "documentation", "name": "__overview__"}}, "nodes": {"model.gdelt.base_spotify_stock_data": {"description": "", "resource_type": "model", "fqn": ["gdelt", "base", "base_spotify_stock_data"], "package_name": "gdelt", "original_file_path": "models/base/base_spotify_stock_data.sql", "database": "SB_HACKATHON_DB_TEAM1", "depends_on": {"macros": [], "nodes": []}, "refs": [], "root_path": "/mnt/c/Users/vanna.trieu/Documents/dbt_projects/gdelt", "raw_sql": "-- Welcome to your first dbt model!\r\n-- Did you know that you can also configure models directly within\r\n-- the SQL file? This will override configurations stated in dbt_project.yml\r\n\r\n-- Try changing 'view' to 'table', then re-running dbt\r\n{{ config(materialized='view') }}\r\n\r\n\r\nselect * from SPOTIFY_STOCK_DATA", "sources": [], "alias": "base_spotify_stock_data", "unique_id": "model.gdelt.base_spotify_stock_data", "path": "base/base_spotify_stock_data.sql", "tags": [], "schema": "GDELT_RAW", "config": {"vars": {}, "tags": [], "materialized": "view", "quoting": {}, "post-hook": [], "enabled": true, "pre-hook": [], "column_types": {}}, "columns": {}, "empty": false, "name": "base_spotify_stock_data"}, "model.gdelt.base_spotify_in_url": {"description": "", "resource_type": "model", "fqn": ["gdelt", "base", "base_spotify_in_url"], "package_name": "gdelt", "original_file_path": "models/base/base_spotify_in_url.sql", "database": "SB_HACKATHON_DB_TEAM1", "depends_on": {"macros": [], "nodes": []}, "refs": [], "root_path": "/mnt/c/Users/vanna.trieu/Documents/dbt_projects/gdelt", "raw_sql": "--Spotify directly referenced in Source URLs; base model\r\n\r\n{{ config(materialized='view') }}\r\n\r\nselect * \r\nfrom GLOBAL_EVENT_V2\r\nwhere lower(SOURCEURL) like '%spotify%'", "sources": [], "alias": "base_spotify_in_url", "unique_id": "model.gdelt.base_spotify_in_url", "path": "base/base_spotify_in_url.sql", "tags": [], "schema": "GDELT_RAW", "config": {"vars": {}, "tags": [], "materialized": "view", "quoting": {}, "post-hook": [], "enabled": true, "pre-hook": [], "column_types": {}}, "columns": {}, "empty": false, "name": "base_spotify_in_url"}, "model.gdelt.xf_spotify_aggregated": {"description": "", "resource_type": "model", "fqn": ["gdelt", "xf", "xf_spotify_aggregated"], "package_name": "gdelt", "original_file_path": "models/xf/xf_spotify_aggregated.sql", "database": "SB_HACKATHON_DB_TEAM1", "depends_on": {"macros": [], "nodes": ["model.gdelt.base_spotify_stock_data", "model.gdelt.xf_spotify_date"]}, "refs": [["base_spotify_stock_data"], ["xf_spotify_date"]], "root_path": "/mnt/c/Users/vanna.trieu/Documents/dbt_projects/gdelt", "raw_sql": "--aggregating xf_spotify_date\r\n\r\n{{ config(materialized='view') }}\r\n\r\nwith SPOTIFY_STOCK_DATA as \r\n(\r\n    select * from {{ref('base_spotify_stock_data')}}\r\n),\r\n\r\nSPOTIFY_STOCK_DATE as\r\n(\r\n    select * from {{ref('xf_spotify_date')}}\r\n)\r\n\r\nselect \r\n      Date_Added\r\n    , Spotify\r\n    , avg(GoldsteinScale) as Avg_GoldensteinScale\r\n    , avg(NumArticles) as Avg_Articles\r\n    , avg(AvgTone) as Avg_Tone\r\n    , avg(Open) as \"Open\"\r\n    , avg(Close) as \"Close\"\r\nfrom SPOTIFY_STOCK_DATE DT  left join SPOTIFY_STOCK_DATA DTA on DT.Date_Added = DTA.\"Date\"\r\ngroup by Date_Added, Spotify \r\norder by Date_added asc", "sources": [], "alias": "xf_spotify_aggregated", "unique_id": "model.gdelt.xf_spotify_aggregated", "path": "xf/xf_spotify_aggregated.sql", "tags": [], "schema": "GDELT_RAW", "config": {"vars": {}, "tags": [], "materialized": "view", "quoting": {}, "post-hook": [], "enabled": true, "pre-hook": [], "column_types": {}}, "columns": {}, "empty": false, "name": "xf_spotify_aggregated"}, "model.gdelt.xf_spotify_date": {"description": "", "resource_type": "model", "fqn": ["gdelt", "xf", "xf_spotify_date"], "package_name": "gdelt", "original_file_path": "models/xf/xf_spotify_date.sql", "database": "SB_HACKATHON_DB_TEAM1", "depends_on": {"macros": [], "nodes": ["model.gdelt.base_spotify_in_url"]}, "refs": [["base_spotify_in_url"]], "root_path": "/mnt/c/Users/vanna.trieu/Documents/dbt_projects/gdelt", "raw_sql": "--Reformatting dates; xf\r\n\r\n-- configuring this model as ephemeral so that it doesn't get materialized in the db\r\n{{ config(materialized='ephemeral') }}\r\n\r\n\r\nselect \r\n      to_timestamp_ntz(cast(DATEADDED as string), 'YYYYMMDD HH24MISS') as Date_Added\r\n    , GoldsteinScale\r\n    , NumArticles\r\n    , AvgTone\r\n    , 'Spotify Mention' as Spotify\r\n    , SourceURL\r\nfrom {{ref('base_spotify_in_url')}} --using ref() functions, dbt understands dependencies between models and creates DAGs in  proper order \r\nwhere NumArticles is not null and NumMentions is not null and AvgTone is not null\r\norder by dateadded asc", "sources": [], "alias": "xf_spotify_date", "unique_id": "model.gdelt.xf_spotify_date", "path": "xf/xf_spotify_date.sql", "tags": [], "schema": "GDELT_RAW", "config": {"vars": {}, "tags": [], "materialized": "ephemeral", "quoting": {}, "post-hook": [], "enabled": true, "pre-hook": [], "column_types": {}}, "columns": {}, "empty": false, "name": "xf_spotify_date"}}, "disabled": [], "metadata": {"send_anonymous_usage_stats": true, "project_id": "83e90eb2b3beb5b68a213cdd737346c0", "user_id": "7f971463-cab9-44c1-96ca-fe95cb860d11"}}